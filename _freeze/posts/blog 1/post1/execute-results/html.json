{
  "hash": "bcb867b7762a5086313895d1da5735c8",
  "result": {
    "markdown": "---\ntitle: \"Probability Theory\"\nsubtitle: \"Using Python to Show the Basics of Probability\"\nauthor: \"Aniket Adhikari\"\ndate: \"2023-11-13\"\ndate-modified: \"2023-11-15\"\nimage: \"https://static.wikia.nocookie.net/pokemon-snakewood/images/7/77/Pikachu.png/revision/latest?cb=20220124235719\"\ntoc: true\ntoc-title: \"On this page\"\ncode-line-numbers: true\nhighlight-style: dracula\nformat:\n  html:\n    embed-resources: true\n    code-tools: true\n  pdf:\n    colorlinks: true\n---\n\n# What is Probability Theory?\nThe outcome of random events like rolling a pair of dice are impossible to predict with absolute certainty. Probability theory provides a mathematical framework for quantifying uncertainty and randomness in these situations where outcome is not deterministic. \n\nUnder the umbrella of probability theory is a couple of key concepts that I will be going through, such as:\n\n-   Random Variables\n-   Independence\n-   Conditional Probability\n-   Bayes Theorem\n\n# Areas of Importance\n\nProbability theory has proven to be crucial in various fields including, but not limited to: \n\n## Economics\n\nIn economics, probability models are used to forecast certain economic indicators like annual GDP growth, inflation, and unemployment rates. Through these forecasts, policymakers are able to make informed decisions about the macroeconomy [2]\n\n## Finance \n\nProbability theory is fundamental for assessing risk in financial markets. It has a massive influence on how institutional and individual investors make decisions regarding buying and selling of securities. It also influences the way financial derivatives like options are priced by sellers [2].\n\n## Medicine\n\n3 years ago, the whole world was shut down by COVID-19, which resulted in many people falling ill. In instances like this, epidemiologists utilize predictive algorithms to measure the probability of patients being carriers disease carriers based on symptom screening. By identifying novel cases of COVID-19, there is potential that it can be identified early, which can help to reduce long-term complications and even save lives [3]\n\n# Random Variables \nIn the context of probability theory, a random variable is usually designated as $X$ and can take on different numerical values a as result of random events/experiments. The numerical values associated with the outcome of the event are determined by the underlying probability space[4].[5]. There are 2 types of random variables values: \n\n## Discrete Variable\n**Discrete variables** are variables that can only take on certain discrete, countable values. It is restricted to integers and can not be represented as a decimal or fraction. \n\nExamples:\n- Counts and integers like number of items or scores\n- Binary variables like pass/fail or yes/no \n- Rating scales like rating movies on a 1-5 star scale\n- Event outcomes such as a dice roll or coin flip\n\n## Continuous Variables\n**Continuous variables** are able to take on an infinite number of real values within a range. It can take on fractional or decimal values in addition to integer values.\n\nExamples: \n* Physical measurements like height, weight, temperature\n* Time, geographic coordinates\n* Natural phenomena like air pressure \n\n#  Independence\nIn probability theory, we say that two events $A$ and $B$ are independent if the occurence of one of the events does not effect the probability of the other event. That is, $P(A|B)=P(A)$ and $P(B|A)=P(B)$. \n\nFor independent events, the probability of both occuring is the product of their respective probabilities. That is, $P(A \\cap B)=P(A)*P(B)$\n\nIndependence can be used to determine whether the probability of one event is dependent on the outcome of another or not. Events that are not independent are dependent, meaning the occurence of one event influences the outcome of another. In statists, we want samples to be independent so we don't introduce bias.\n\nAn example of independence would be a coin flip.  If we were to flip 2 coins, the outcome of one of the coins is not going to effect the other since they are independent. Another example would be rolling a pair of dice. The outcome of one dice does not affect another pair.\n\n# Conditional Probability\nConditional probability refers to the measure of probability of an event $A$ occuring, given an another event $B$ has already occured. That us, $P(A|B)$. \n\nAn example of conditional probability would be the probability that someone has the flu, given they are coughing. \n\n# Bayes' Theorem\nBayes' Theorem is a formula that is used to calculate conditional probabilities. Essentially, it describes the probability of an event $A$, given that there is some new information $B$. That is, $P(A|B) = \\frac{P(B|A) \\cdot P(A)}{P(B)}$. \n\nBayes' Theorem is really useful in Machine Learning and statistics since it is used to update probability distributions based on observed data. \n\n# Application\nWe start off by importing `pandas`, which will allow us to extract, aggregate, and analyze our data. We also need to import   `matplotlib` since we need to visualize the data as well.\n\nThe aesthetic of the visualizations are altered as well. The size of the legend, axis, ticks, and font are all altered. \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nplt.rc('font', size=12) # font size \nplt.rc('axes', labelsize=14, titlesize=14) # font size of axis and label titles \nplt.rc('legend', fontsize=12) # font size of legend\nplt.rc('xtick', labelsize=5) # size of ticks on x-axis\nplt.rc('ytick', labelsize=10) # size of ticks on y-axis\n```\n:::\n\n\nI decided to use a dataset from Kaggle of the first 7 generations of Pokemon. Pokemon is a really old video game franchise and essentially any time a new game was made, they would come up new Pokemon. The new Pokemon for the game would comprise of a generation and usually there's around 100 or more Pokemon per generation. This dataset shows basic information about Pokemon such as their names, weight, height, and number in the Pokedex. Additionally, it includes information that can be interesting to analyze when aggregated, such as attack, defense, hit points (HP), generation, if they are considered legendary, and much more.\n\nHere, we are loading the csv file and converting it into a `pandas` Series so that it can be examined. \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndata_source_raw = \"../../datasets/pokemon.csv\"\ndata_source_result = pd.read_csv(data_source_raw)\ndata_source_result\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>attack</th>\n      <th>base_egg_steps</th>\n      <th>base_happiness</th>\n      <th>base_total</th>\n      <th>capture_rate</th>\n      <th>defense</th>\n      <th>experience_growth</th>\n      <th>height_m</th>\n      <th>hp</th>\n      <th>name</th>\n      <th>percentage_male</th>\n      <th>pokedex_number</th>\n      <th>sp_attack</th>\n      <th>sp_defense</th>\n      <th>speed</th>\n      <th>type1</th>\n      <th>type2</th>\n      <th>weight_kg</th>\n      <th>generation</th>\n      <th>is_legendary</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>49</td>\n      <td>5120</td>\n      <td>70</td>\n      <td>318</td>\n      <td>45</td>\n      <td>49</td>\n      <td>1059860</td>\n      <td>0.7</td>\n      <td>45</td>\n      <td>Bulbasaur</td>\n      <td>88.1</td>\n      <td>1</td>\n      <td>65</td>\n      <td>65</td>\n      <td>45</td>\n      <td>grass</td>\n      <td>poison</td>\n      <td>6.9</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>62</td>\n      <td>5120</td>\n      <td>70</td>\n      <td>405</td>\n      <td>45</td>\n      <td>63</td>\n      <td>1059860</td>\n      <td>1.0</td>\n      <td>60</td>\n      <td>Ivysaur</td>\n      <td>88.1</td>\n      <td>2</td>\n      <td>80</td>\n      <td>80</td>\n      <td>60</td>\n      <td>grass</td>\n      <td>poison</td>\n      <td>13.0</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>100</td>\n      <td>5120</td>\n      <td>70</td>\n      <td>625</td>\n      <td>45</td>\n      <td>123</td>\n      <td>1059860</td>\n      <td>2.0</td>\n      <td>80</td>\n      <td>Venusaur</td>\n      <td>88.1</td>\n      <td>3</td>\n      <td>122</td>\n      <td>120</td>\n      <td>80</td>\n      <td>grass</td>\n      <td>poison</td>\n      <td>100.0</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>52</td>\n      <td>5120</td>\n      <td>70</td>\n      <td>309</td>\n      <td>45</td>\n      <td>43</td>\n      <td>1059860</td>\n      <td>0.6</td>\n      <td>39</td>\n      <td>Charmander</td>\n      <td>88.1</td>\n      <td>4</td>\n      <td>60</td>\n      <td>50</td>\n      <td>65</td>\n      <td>fire</td>\n      <td>NaN</td>\n      <td>8.5</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>64</td>\n      <td>5120</td>\n      <td>70</td>\n      <td>405</td>\n      <td>45</td>\n      <td>58</td>\n      <td>1059860</td>\n      <td>1.1</td>\n      <td>58</td>\n      <td>Charmeleon</td>\n      <td>88.1</td>\n      <td>5</td>\n      <td>80</td>\n      <td>65</td>\n      <td>80</td>\n      <td>fire</td>\n      <td>NaN</td>\n      <td>19.0</td>\n      <td>1</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>796</th>\n      <td>101</td>\n      <td>30720</td>\n      <td>0</td>\n      <td>570</td>\n      <td>25</td>\n      <td>103</td>\n      <td>1250000</td>\n      <td>9.2</td>\n      <td>97</td>\n      <td>Celesteela</td>\n      <td>NaN</td>\n      <td>797</td>\n      <td>107</td>\n      <td>101</td>\n      <td>61</td>\n      <td>steel</td>\n      <td>flying</td>\n      <td>999.9</td>\n      <td>7</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>797</th>\n      <td>181</td>\n      <td>30720</td>\n      <td>0</td>\n      <td>570</td>\n      <td>255</td>\n      <td>131</td>\n      <td>1250000</td>\n      <td>0.3</td>\n      <td>59</td>\n      <td>Kartana</td>\n      <td>NaN</td>\n      <td>798</td>\n      <td>59</td>\n      <td>31</td>\n      <td>109</td>\n      <td>grass</td>\n      <td>steel</td>\n      <td>0.1</td>\n      <td>7</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>798</th>\n      <td>101</td>\n      <td>30720</td>\n      <td>0</td>\n      <td>570</td>\n      <td>15</td>\n      <td>53</td>\n      <td>1250000</td>\n      <td>5.5</td>\n      <td>223</td>\n      <td>Guzzlord</td>\n      <td>NaN</td>\n      <td>799</td>\n      <td>97</td>\n      <td>53</td>\n      <td>43</td>\n      <td>dark</td>\n      <td>dragon</td>\n      <td>888.0</td>\n      <td>7</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>799</th>\n      <td>107</td>\n      <td>30720</td>\n      <td>0</td>\n      <td>600</td>\n      <td>3</td>\n      <td>101</td>\n      <td>1250000</td>\n      <td>2.4</td>\n      <td>97</td>\n      <td>Necrozma</td>\n      <td>NaN</td>\n      <td>800</td>\n      <td>127</td>\n      <td>89</td>\n      <td>79</td>\n      <td>psychic</td>\n      <td>NaN</td>\n      <td>230.0</td>\n      <td>7</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>800</th>\n      <td>95</td>\n      <td>30720</td>\n      <td>0</td>\n      <td>600</td>\n      <td>3</td>\n      <td>115</td>\n      <td>1250000</td>\n      <td>1.0</td>\n      <td>80</td>\n      <td>Magearna</td>\n      <td>NaN</td>\n      <td>801</td>\n      <td>130</td>\n      <td>115</td>\n      <td>65</td>\n      <td>steel</td>\n      <td>fairy</td>\n      <td>80.5</td>\n      <td>7</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n<p>801 rows Ã— 20 columns</p>\n</div>\n```\n:::\n:::\n\n\nTaking a look at the data output, we can see there are 20 columns total. We can then run the `info()` command on the dataset to get a breakdown of datatypes and more.\n\nAs shown below, 16 of the 20 columns are numerical values. Of the 16, some of them are *discrete variables*:\n\n* `base_egg_steps`\n* `base_happiness`\n* `experience_growth`\n* `hp`\n* `pokedex_number`\n* `generation`\n* `is_legendary`\n\nThe others are *continuous variables*:\n\n* `attack`\n* `defense`\n* `base_total`\n* `sp_attack`\n* `sp_defense`\n* `height_m`\n* `percentage_male`\n* `speed`\n* `weight_kg`\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndata_source_result.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 801 entries, 0 to 800\nData columns (total 20 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   attack             801 non-null    int64  \n 1   base_egg_steps     801 non-null    int64  \n 2   base_happiness     801 non-null    int64  \n 3   base_total         801 non-null    int64  \n 4   capture_rate       801 non-null    object \n 5   defense            801 non-null    int64  \n 6   experience_growth  801 non-null    int64  \n 7   height_m           781 non-null    float64\n 8   hp                 801 non-null    int64  \n 9   name               801 non-null    object \n 10  percentage_male    703 non-null    float64\n 11  pokedex_number     801 non-null    int64  \n 12  sp_attack          801 non-null    int64  \n 13  sp_defense         801 non-null    int64  \n 14  speed              801 non-null    int64  \n 15  type1              801 non-null    object \n 16  type2              417 non-null    object \n 17  weight_kg          781 non-null    float64\n 18  generation         801 non-null    int64  \n 19  is_legendary       801 non-null    int64  \ndtypes: float64(3), int64(13), object(4)\nmemory usage: 125.3+ KB\n```\n:::\n:::\n\n\nGetting specific columns that are important. \n\nThere's a lot of information in this file, with a lot of it being unnecessary at the moment.\n\nAs a result, we're going to filter for specific columns and we're going to rename the columns. In this code, we filter for the `generation` and `is_legendary` column so we don't have to rename every single column. Instead, we're just renaming the columns that are important to us. We rename `generation` to `Generation` and `is_legendary` to `Legendary`\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ngeneration_legends = data_source_result[[\"generation\", \"is_legendary\"]]\ngeneration_legends = generation_legends.rename(columns={'is_legendary':\"Legendary\", 'generation':\"Generation\"})\n```\n:::\n\n\nAfterwards, we determine how many legendary Pokemon are there for each generation.\n\nIn this example, `generation` represents a discrete variable since it exists as an integer within a fixed range of 1-7. \n\nWe find that the generation with the most legenedary Pokemon is generation 7. This is done by running the `groupby()` function on the `generation` column then subsequently running `agg` to find the number of legendary pokemon.\n\nOnce we sort, it becomes increasingly clear which that Generations 7, 4, 5 are the most ripe with legendary Pokemon\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nlegendary_per_generation = generation_legends.groupby(\"Generation\").agg({\"Legendary\":\"sum\", \"Generation\":\"first\"})\nlegendary_per_generation[['Legendary']].sort_values(by=\"Legendary\", ascending=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Legendary</th>\n    </tr>\n    <tr>\n      <th>Generation</th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>7</th>\n      <td>17</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>13</td>\n    </tr>\n    <tr>\n      <th>5</th>\n      <td>13</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>10</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>6</th>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>5</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nGetting the data, we can now visualize it on a bar graph to compare the number of legendary pokemon across generation.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nlegendary_per_generation.plot(kind=\"bar\", x=\"Generation\", y=\"Legendary\", title=\"Legendary Pokemon Per Generation\", ylabel=\"Number of Legendary Pokemon\", legend=False)\nplt.axis([-1,7 , 0, 25])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](post1_files/figure-html/cell-7-output-1.png){width=590 height=448}\n:::\n:::\n\n\nSo we've simply pointed out discrete variables and continuous variables here. We've managed to create a discrete variable by counting the number of legendary Pokemon. But what does this have to do with probability? Well we can take a closer look at Pokemon from a specific generation and break it down further. Here we can figure out what are the odds that a Pokemon from Generation 7 is classified as Legendary?\n\nWe've already imported everything we need, so we need to start by filtering by the generation. Here we have filtered so that only Pokemon from generation 7 will appear.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ngeneration_num = 7\ngen7_pokemon = data_source_result[data_source_result['generation']==generation_num]\n```\n:::\n\n\nNow that we've gotten the specific Pokemon that we want, we also need to get the column we want. Here we are using the `is_legendary` column because we are evaluating which Pokemon are and aren't legendary. While we could get the count of each, it is probably more meaningful to get percentage breakdowns of them. As a result, we use `value_counts` to get the probability of 0 or 1, but we also normalize the results so as to get percentage values rather than just a count.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nlegendary_pokemon = gen7_pokemon['is_legendary']\nlegendary_percentages = legendary_pokemon.value_counts(normalize=True)\n```\n:::\n\n\nFrom there, we use 0 and 1 as index values and the percentages that were calculated earlier are used as the values. \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nlegendary_percentages = pd.Series(legendary_percentages.values, index=legendary_pokemon.unique())\n```\n:::\n\n\nFrom there, I created a pie graph since we're only comparing 2 values. As we can see, there is 78.75% non-legendary Pokemon and 21.25% legendary Pokemon in Generation 7.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nlegendary_percentages.plot(kind=\"pie\", ylabel=\"\", title=\"% of Legendary Gen 7 Pokemon\", labels=[\"Not Legendary\", \"Legendary\"], autopct='%.1f%%')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](post1_files/figure-html/cell-11-output-1.png){width=389 height=411}\n:::\n:::\n\n\nWe could also factor in conditional probablity and Bayes' Theorem. If we were to play a guessing game for every single Pokemon in this dataset, guessing the right Pokemon would be really challenging because there is over 800 Pokemon. We would have only a 0.12% chance of guessing right!\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ntotal_num_pokemon = data_source_result['pokedex_number'].count()\n1/total_num_pokemon \n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n0.0012484394506866417\n```\n:::\n:::\n\n\nBut what if we found out that the Pokemon is in Generation 1 and is also a legendary pokemon? That would certainly increase our odds!\n\nHere we can filter for Pokemon that appear in Generation 1, filter for the legendary Pokemon, and then get the count which is 5. \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ngen1_pokemon = data_source_result[data_source_result['generation']==1]\nlegendary_gen1 = gen1_pokemon[gen1_pokemon['is_legendary']==1]\nlegendary_gen1_count = legendary_gen1['name'].count()\n```\n:::\n\n\nWe then do 1 divided by the count to get our new odds. We have improved our guessing odds from 0.1% to 20%!\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n1/legendary_gen1_count \n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n0.2\n```\n:::\n:::\n\n\nThis showcasing *Bayes' Theorem*, which suggests bringing in new evidence will effect the outcome of the event. In our case, we found out that the Pokemon we were looking for is in Generation 1 and Legendary. \n\n",
    "supporting": [
      "post1_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}